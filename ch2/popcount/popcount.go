package main

import "fmt"

// Будет заполнен подсчитаным количеством единичных бит
// во всех 256 комбинациях для одного байта
var pc [256]byte

// Алгоритм функции init():
// количество бит для кажного элемента высчитывает по очереди.
// Берётся индекс элемента, для его двоичного представления производится сдвиг вправа на 1,
// затем к полученному числа прибаляется младший бит двоичного представления индеса элемента.
// Младший бит получаем с помошью операции конъюнкции(и) индекса и числа 1.
// Объяснение: 3 = 11b; pc[3>>1] = 01b; byte(3&1) = 11b & 01b = 01b; pc[3] = 01b + 01b = 10b = 2

func init() {
	for i := range pc {
		pc[i] = pc[i>>1] + byte(i&1)
	}
}

// PopCount - функция похода по массиву pc и сложения результата.
// Нагладнее понимается на больших числах, к примеру 5000
// 5000 = 1001110001000b
// В нулевой итерации 1001110001000b сдвигается на 0 бит и берётся младший байт.
// Результат: 10001000b, что соответствует 136. По этому индексу в массиве pc значение 2.
// В первой итерацииц 1001110001000b сдвигается на 8 бит и берётся младший байт.
// Результат: 00010011b, что соответствует 19. По этому индексу в массиве pc значение 3.
// и т.д.
// Результаты складываются.
func PopCount(x uint64) int {
	var result int
	for i := 0; i < 8; i++ {
		result += int(pc[byte(x>>(i*8))])
		fmt.Printf("result = %d\n", result) // Добавил для наглядности
	}
	return result
}

func main() {
	fmt.Printf("pc = %d\n\n", pc)
	fmt.Printf("x = %b, popcount = %d\n", 5000, PopCount(5000))
}
