
<!DOCTYPE html>
<html lang="en">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-11222381-3"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag("js", new Date());
gtag("config", "UA-11222381-3");
gtag("config", "UA-49880327-6");
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#00ADD8">
<meta name="description" content="Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.">
<title>Defer, Panic, and Recover - The Go Blog</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Work+Sans:600|Roboto:400,700|Source+Code+Pro">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Product+Sans&text=Supported%20by%20Google&display=swap">
<link rel="stylesheet" href="/lib/godoc/style.css">
<link rel="stylesheet" href="/fonts.css">
<link rel="alternate" type="application/atom+xml" title="blog.golang.org - Atom Feed" href="https://blog.golang.org/feed.atom" />
<script>window.initFuncs = [];</script>
<style>
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: 'Work Sans', sans-serif;
    font-weight: 600;
  }
  h2 {  
    background: none;
    clear: none;
    font-size: 1.5em;
    font-weight: 600;
    line-height: inherit;
    overflow-wrap: normal;
    padding: 0;
  }
  @media print {
    #sidebar { display: none; }
  }
  #sidebar {
    float: right;
    padding-left: 20px;
    width: 40%;
    max-width: 250px;
    background: #f8f9f9;
    margin: 20px 0 20px 20px;
  }
  #sidebar h2 {
    font-size: 1rem;
  }
  #sidebar ul {
    padding: 0;
  }
  #sidebar li {
    list-style-type: none;
  }
  #content .author {
    font-style: italic;
  }
  #content .article {
    margin-bottom: 50px;
  }
  #content .date {
    color: #6e7072;
  }
  #content .tags {
    color: #999;
    font-size: smaller;
  }
  #content .iframe, #content .image {
    margin: 20px;
  }
  #content .title {
    margin: 20px 0;
  }
  #content img {
    max-width: 100%;
  }
  .article[data-slug='/go-fonts'] {
    font-family: Go, sans-serif;
  }
  .article[data-slug='/go-fonts'] pre,
  .article[data-slug='/go-fonts'] code {
    font-family: 'Go Mono', monospace;
  }
</style>
<body class="Site">
  <header class="Header js-header">
    <nav class="Header-nav">
      <a href="https://golang.org"><img class="Header-logo" src="/lib/godoc/images/go-logo-blue.svg" alt="Go"></a>
      <button class="Header-menuButton js-headerMenuButton" aria-label="Main menu" aria-expanded="false">
        <div class="Header-menuButtonInner">
      </button>
      <ul class="Header-menu">
        <li class="Header-menuItem"><a href="https://golang.org/doc/">Documents</a></li>
        <li class="Header-menuItem"><a href="https://golang.org/pkg/">Packages</a></li>
        <li class="Header-menuItem"><a href="https://golang.org/project/">The Project</a></li>
        <li class="Header-menuItem"><a href="https://golang.org/help/">Help</a></li>
        <li class="Header-menuItem"><a href="/">Blog</a></li>
        <li class="Header-menuItem"><a href="https://play.golang.org/">Play</a></li>
        <li class="Header-menuItem Header-menuItem--search">
          <form class="HeaderSearch" role="search" action="https://golang.org/search">
            <input class="HeaderSearch-input"
                  type="search"
                  name="q"
                  placeholder="Search"
                  aria-label="Search"
                  autocapitalize="off"
                  autocomplete="off"
                  autocorrect="off"
                  spellcheck="false"
                  required>
            <button class="HeaderSearch-submit" aria-label="Search">
              <svg class="HeaderSearch-icon" width="24" height="24" viewBox="0 0 24 24"><title>Search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg>
            </button>
          </form>
        </li>
      </ul>
    </nav>
  </header>

  <main class="Site-content" id="page">
    <div class="container">
      <aside id="sidebar">
        
          
            <h2>Next article</h2>
            <p><a href="/bossie">Go Wins 2010 Bossie Award</a></p>
          

          
            <h2>Previous article</h2>
            <p><a href="/codelab-share">Share Memory By Communicating</a></p>
          
        

        <h2>Links</h2>
        <ul>
          <li><a href='//golang.org/'>golang.org</a></li>
          <li><a href='//golang.org/doc/install.html'>Install Go</a></li>
          <li><a href='//tour.golang.org/'>A Tour of Go</a></li>
          <li><a href='//golang.org/doc/'>Go Documentation</a></li>
          <li><a href='//groups.google.com/group/golang-nuts'>Go Mailing List</a></li>
          <li><a href='//twitter.com/golang'>Go on Twitter</a></li>
        </ul>

        <p><a href="/index">Blog index</a></p>
      </aside>

      <div id="content">
        <h1><a href="/">The Go Blog</a></h1>
        
	
  <div class="article" data-slug="/defer-panic-and-recover">
    <h2 class="title"><a href="/defer-panic-and-recover">Defer, Panic, and Recover</a></h2>
    <p class="author">
    Andrew Gerrand<br>
    4 August 2010
    </p>
    
  
  
    
      
        <p>Go has the usual mechanisms for control flow:
if, for, switch, goto.
It also has the go statement to run code in a separate goroutine.
Here I'd like to discuss some of the less common ones:
defer, panic, and recover.</p>
<p>A <strong>defer statement</strong> pushes a function call onto a list.
The list of saved calls is executed after the surrounding function returns.
Defer is commonly used to simplify functions that perform various clean-up actions.</p>
<p>For example, let's look at a function that opens two files and copies the contents of one file to the other:</p>
<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }

    written, err = io.Copy(dst, src)
    dst.Close()
    src.Close()
    return
}
</code></pre>
<p>This works, but there is a bug. If the call to os.Create fails,
the function will return without closing the source file.
This can be easily remedied by putting a call to src.Close before the second return statement,
but if the function were more complex the problem might not be so easily
noticed and resolved.
By introducing defer statements we can ensure that the files are always closed:</p>
<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }
    defer dst.Close()

    return io.Copy(dst, src)
}
</code></pre>
<p>Defer statements allow us to think about closing each file right after opening it,
guaranteeing that, regardless of the number of return statements in the function,
the files <em>will</em> be closed.</p>
<p>The behavior of defer statements is straightforward and predictable. There are three simple rules:</p>
<ol>
<li><em>A deferred function's arguments are evaluated when the defer statement is evaluated.</em></li>
</ol>
<p>In this example, the expression &quot;i&quot; is evaluated when the Println call is deferred.
The deferred call will print &quot;0&quot; after the function returns.</p>
<pre><code>func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}
</code></pre>
<ol start="2">
<li><em>Deferred function calls are executed in Last In First Out order after the surrounding function returns.</em></li>
</ol>
<p>This function prints &quot;3210&quot;:</p>
<pre><code>func b() {
    for i := 0; i &lt; 4; i++ {
        defer fmt.Print(i)
    }
}
</code></pre>
<ol start="3">
<li><em>Deferred functions may read and assign to the returning function's named return values.</em></li>
</ol>
<p>In this example, a deferred function increments the return value i <em>after</em>
the surrounding function returns.
Thus, this function returns 2:</p>
<pre><code>func c() (i int) {
    defer func() { i++ }()
    return 1
}
</code></pre>
<p>This is convenient for modifying the error return value of a function; we will see an example of this shortly.</p>
<p><strong>Panic</strong> is a built-in function that stops the ordinary flow of control and begins <em>panicking</em>.
When the function F calls panic, execution of F stops,
any deferred functions in F are executed normally,
and then F returns to its caller.
To the caller, F then behaves like a call to panic.
The process continues up the stack until all functions in the current goroutine have returned,
at which point the program crashes.
Panics can be initiated by invoking panic directly.
They can also be caused by runtime errors,
such as out-of-bounds array accesses.</p>
<p><strong>Recover</strong> is a built-in function that regains control of a panicking goroutine.
Recover is only useful inside deferred functions.
During normal execution, a call to recover will return nil and have no other effect.
If the current goroutine is panicking, a call to recover will capture the
value given to panic and resume normal execution.</p>
<p>Here's an example program that demonstrates the mechanics of panic and defer:</p>
<pre><code>package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>
<p>The function g takes the int i, and panics if i is greater than 3,
or else it calls itself with the argument i+1.
The function f defers a function that calls recover and prints the recovered
value (if it is non-nil).
Try to picture what the output of this program might be before reading on.</p>
<p>The program will output:</p>
<pre><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
</code></pre>
<p>If we remove the deferred function from f the panic is not recovered and
reaches the top of the goroutine's call stack,
terminating the program.
This modified program will output:</p>
<pre><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
panic: 4

panic PC=0x2a9cd8
[stack trace omitted]
</code></pre>
<p>For a real-world example of <strong>panic</strong> and <strong>recover</strong>,
see the <a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener">json package</a> from the
Go standard library.
It encodes an interface with a set of recursive functions.
If an error occurs when traversing the value,
panic is called to unwind the stack to the top-level function call,
which recovers from the panic and returns an appropriate error value (see
the 'error' and 'marshal' methods of the encodeState type in <a href="https://golang.org/src/pkg/encoding/json/encode.go" target="_blank" rel="noopener">encode.go</a>).</p>
<p>The convention in the Go libraries is that even when a package uses panic internally,
its external API still presents explicit error return values.</p>
<p>Other uses of <strong>defer</strong> (beyond the file.Close example given earlier) include releasing a mutex:</p>
<pre><code>mu.Lock()
defer mu.Unlock()
</code></pre>
<p>printing a footer:</p>
<pre><code>printHeader()
defer printFooter()
</code></pre>
<p>and more.</p>
<p>In summary, the defer statement (with or without panic and recover) provides
an unusual and powerful mechanism for control flow.
It can be used to model a number of features implemented by special-purpose
structures in other programming languages. Try it out.</p>

      
    
  

  </div>

	
		<h2>Related articles</h2>
		<ul>
		
			<li><a href="/protobuf-apiv2">A new Go API for Protocol Buffers</a></li>
		
			<li><a href="/go1.13-errors">Working with Errors in Go 1.13</a></li>
		
			<li><a href="/debug-opt">Debugging what you deploy in Go 1.12</a></li>
		
			<li><a href="/h2push">HTTP/2 Server Push</a></li>
		
			<li><a href="/http-tracing">Introducing HTTP Tracing</a></li>
		
			<li><a href="/generate">Generating code</a></li>
		
			<li><a href="/race-detector">Introducing the Go Race Detector</a></li>
		
			<li><a href="/maps">Go maps in action</a></li>
		
			<li><a href="/gofmt">go fmt your code</a></li>
		
			<li><a href="/organizing-go-code">Organizing Go code</a></li>
		
			<li><a href="/debug-gdb">Debugging Go programs with the GNU Debugger</a></li>
		
			<li><a href="/image-draw">The Go image/draw package</a></li>
		
			<li><a href="/image">The Go image package</a></li>
		
			<li><a href="/laws-of-reflection">The Laws of Reflection</a></li>
		
			<li><a href="/error-handling-and-go">Error handling and Go</a></li>
		
			<li><a href="/functions-codewalk">First Class Functions in Go</a></li>
		
			<li><a href="/pprof">Profiling Go Programs</a></li>
		
			<li><a href="/gif-decoder">A GIF decoder: an exercise in Go interfaces</a></li>
		
			<li><a href="/introducing-gofix">Introducing Gofix</a></li>
		
			<li><a href="/godoc">Godoc: documenting Go code</a></li>
		
			<li><a href="/gob">Gobs of data</a></li>
		
			<li><a href="/cgo">C? Go? Cgo!</a></li>
		
			<li><a href="/json">JSON and Go</a></li>
		
			<li><a href="/slices-intro">Go Slices: usage and internals</a></li>
		
			<li><a href="/concurrency-timeouts">Go Concurrency Patterns: Timing out, moving on</a></li>
		
			<li><a href="/codelab-share">Share Memory By Communicating</a></li>
		
			<li><a href="/json-rpc">JSON-RPC: a tale of interfaces</a></li>
		
		</ul>
	

      </div>

    </div>
  </main>

  <footer>
    <div class="Footer">
      <img class="Footer-gopher" src="/lib/godoc/images/footer-gopher.jpg" alt="The Go Gopher">
      <ul class="Footer-links">
        <li class="Footer-link"><a href="https://golang.org/doc/copyright.html">Copyright</a></li>
        <li class="Footer-link"><a href="https://golang.org/doc/tos.html">Terms of Service</a></li>
        <li class="Footer-link"><a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a></li>
        <li class="Footer-link"><a href="http://golang.org/issues/new?title=x/blog:" target="_blank" rel="noopener">Report issue</a></li>
      </ul>
      <a class="Footer-supportedBy" href="https://google.com">Supported by Google</a>
    </div>
  </footer>

  <script src="/lib/godoc/jquery.js"></script>
  <script src="/lib/godoc/playground.js"></script>
  <script src="/lib/godoc/play.js"></script>
  <script src="/lib/godoc/godocs.js"></script>
  <script>
  $(function() {
    
    $('.playground > pre.numbers, .code > pre.numbers').each(function() {
      var $spans = $(this).find('> span');

      
      var max = 0;
      $spans.each(function() {
        var n = $(this).attr('num')*1;
        if (n > max) max = n;
      });
      var width = 2;
      while (max > 10) {
        max = max / 10;
        width++;
      }

      
      $spans.each(function() {
        var n = $(this).attr('num')+' ';
        while (n.length < width) n = ' '+n;
        $('<span class="number">').text(n).insertBefore(this);
      });
    });

    initPlayground(new HTTPTransport());
  });
  </script>
